<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Architecture of the Go Zombie Demon - My self-hosted digital-identity blog</title>
    <link rel="stylesheet" href="static/css/style.css">
</head>
<body>
    <header>
        <h1>Architecture of the Go Zombie Demon</h1>
        <p>Published on 2025-02-25 by S1mY</p>
    </header>
    <main>
        <article>
            <h2 id="-">Архитектура демона-зомбовода: технический разбор решения для нестандартной задачи</h2>
<p>Недавно я ходил на интервью в одну IT-компанию на позицию (Site Reliability Engineer/Systems Engineer). Эта позиция предполагает глубокое знание Linux-систем, понимание процессов, системных вызовов и поведения операционной системы под нагрузкой. В целом домен компании очень располагает к детальному пониманию низкоуровневых аспектов работы ОС.</p>
<p>Один небезызвестный архитектор сформулировал передо мной такую задачу: "можно ли написать на Go демона, который порождает армию зомби, и сколько для этого нужно убить детей, и сколько будет занимать памяти, скажем, на 1000 зомби". Да, да, формулировка прям такая xD</p>
<p>Сходу я на этот вопрос комплексно ответить не смог, но сразу после окончания интервью я к ней приступил. Разберем базовые моменты и основные аспекты этого скрипта со всем SE контекстом вокруг него. В этой статье я разберу ключевые технические аспекты реализации такого демона и отвечу на поставленные вопросы.</p>
<h2 id="-_1">Что такое зомби-процессы и демоны?</h2>
<h3 id="-_2">Зомби-процессы</h3>
<p>Начнем с основ. Зомби-процесс в Unix-системах — это процесс, который завершил свое выполнение, но запись о нем всё ещё хранится в таблице процессов ядра операционной системы. Это происходит, когда родительский процесс не вызывает системный вызов wait() для подтверждения завершения дочернего процесса.</p>
<p>Фактически, зомби — это "призрак" процесса, содержащий минимальную информацию: идентификатор процесса (PID), статус завершения и статистику использования ресурсов. Он не потребляет вычислительные ресурсы, но занимает место в таблице процессов ядра.</p>
<h3 id="_1">Демоны</h3>
<p>Демон — это фоновый процесс, который работает независимо от терминала.</p>
<pre class="codehilite"><code class="language-go">func daemonize() error {
    if os.Getppid() != 1 {
        cmd := exec.Command(os.Args[0], os.Args[1:]...)
        cmd.Start()
        os.Exit(0)
    }
    return nil
}
</code></pre>

<p>Разберем этот код:<br />
- Проверка <code>os.Getppid() != 1</code> определяет, является ли родительским процессом init (PID 1). Если нет, значит демон запущен из терминала, и нужно выполнить демонизацию.<br />
- <code>exec.Command(os.Args[0], os.Args[1:]...)</code> создает новый процесс, запускающий ту же программу с теми же аргументами.<br />
- <code>exec.Command</code> в Go — это не прямой системной вызов, а функция из пакета <code>os/exec</code>, которая внутри использует системные вызовы <code>fork</code> и <code>execve</code>.<br />
- После <code>cmd.Start()</code> родительский процесс завершается, а дочерний продолжает работу.</p>
<p>В классической Unix-демонизации обычно используется двойной fork, но в моей реализации достаточно одного, так как Go уже правильно обрабатывает отсоединение от терминала. Фактически же если демон становится лидером сессии, он может случайно получить контрольный терминал (например, <code>/dev/tty1</code>), что недопустимо для фонового процесса, поэтому нужен второй fork. Выглядит двойной fork вот так:</p>
<p>Первый fork:<br />
- Родитель завершается.<br />
- Дочерний процесс вызывает <code>setsid()</code> и становится лидером новой сессии.</p>
<p>Второй fork:<br />
- Лидер сессии завершается.<br />
- Внучатый процесс работает в фоне и не может стать лидером сессии.</p>
<p>Как это реализовать:</p>
<pre class="codehilite"><code class="language-go">// Первый fork
if pid := syscall.Fork(); pid &gt; 0 {
    os.Exit(0)
}

// Создать новую сессию
syscall.Setsid()

// Второй fork
if pid := syscall.Fork(); pid &gt; 0 {
    os.Exit(0)
}
</code></pre>

<p>Fork создает копию процесса, а setsid создает новую сессию, чтобы демон не зависел от терминала.</p>
<p>Технически:<br />
- <code>fork()</code> — системный вызов, создающий точную копию текущего процесса.<br />
- <code>setsid()</code> создает новую сессию и группу процессов.</p>
<p>В моей реализации <code>setsid()</code> вызывается автоматически при демонизации через <code>exec.Command</code>.</p>
<h2 id="_2">Почему процесс не может работать в фоне без отсоединения от терминала?</h2>
<p>Если процесс привязан к терминалу, то при закрытии терминала процесс получит сигнал <code>SIGHUP</code> (Hangup), который по умолчанию завершает процесс. Для работы в фоне независимо от терминала необходимо:<br />
- Отсоединиться от управляющего терминала с помощью <code>setsid()</code>, создавая новую сессию без управляющего терминала.<br />
- Перенаправить стандартные потоки ввода/вывода, обычно в <code>/dev/null</code>, так как терминал становится недоступен.</p>
<p>В Go при использовании <code>exec.Command</code> эти действия выполняются автоматически при создании нового процесса.</p>
<h2 id="pid-">PID-файл и права доступа</h2>
<p>Затем создается PID-файл, который хранит идентификатор процесса демона. Это помогает управлять демоном, например, останавливать его по PID. Сохраняет PID демона в файл для управления (например, <code>kill $(cat /tmp/zombie_daemon.pid)</code>).</p>
<pre class="codehilite"><code class="language-go">os.WriteFile(pidFile, []byte(strconv.Itoa(pid)), 0644)
</code></pre>

<p>Права доступа <code>0644</code> означают:<br />
- <code>6 (110)</code> — владелец: чтение + запись<br />
- <code>4 (100)</code> — группа: чтение<br />
- <code>4 (100)</code> — остальные: чтение</p>
<p>Наличие PID-файла позволяет системным администраторам управлять демоном, например, посылать ему сигналы:</p>
<pre class="codehilite"><code class="language-bash">kill $(cat /tmp/zombie_daemon.pid)
</code></pre>

<h2 id="_3">Обработка сигналов</h2>
<p>Для корректного завершения демона необходимо обрабатывать системные сигналы:</p>
<pre class="codehilite"><code class="language-go">sigChan := make(chan os.Signal, 1)
signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)
go func() {
    &lt;-sigChan
    cancel() // Отмена контекста для завершения всех горутин
}()
</code></pre>

<p>Здесь настраивается перехват сигналов <code>SIGTERM</code> (завершение) и <code>SIGINT</code> (прерывание, обычно Ctrl+C). При получении сигнала выполняется отмена контекста, что приводит к корректному завершению всех горутин.</p>
<h2 id="_4">Создание армии зомби</h2>
<h3 id="_5">Проверка системных ограничений</h3>
<p>Перед массовым созданием процессов важно проверить системные ограничения:</p>
<pre class="codehilite"><code class="language-go">func checkSystemLimits() error {
    var rLimit syscall.Rlimit
    if err := syscall.Getrlimit(6, &amp;rLimit); err != nil { // 6 is RLIMIT_NPROC on Linux
        return fmt.Errorf(&quot;error getting RLIMIT_NPROC: %v&quot;, err)
    }
    if rLimit.Cur &lt; uint64(defaultZombieCount) {
        return fmt.Errorf(&quot;RLIMIT_NPROC too low (%d). Run: ulimit -u %d&quot;,
            rLimit.Cur, defaultZombieCount*2)
    }
    return nil
}
</code></pre>

<p><code>RLIMIT_NPROC</code> определяет максимальное количество процессов, которые пользователь может создать. Если лимит меньше требуемого количества зомби, программа предлагает увеличить его через команду <code>ulimit</code>.</p>
<h3 id="_6">Параллельное создание процессов с ограничением</h3>
<p>Создание тысячи процессов одновременно может перегрузить систему, поэтому используется семафор для ограничения параллелизма:</p>
<pre class="codehilite"><code class="language-go">func createZombies(ctx context.Context, count int) error {
    sem := make(chan struct{}, maxParallelZombies)
    defer close(sem)
    var wg sync.WaitGroup
    for i := 0; i &lt; count; i++ {
        select {
        case &lt;-ctx.Done():
            return nil
        case sem &lt;- struct{}{}:
        }
        wg.Add(1)
        go func() {
            defer func() {
                &lt;-sem
                wg.Done()
            }()
            cmd := exec.Command(truePath)
            cmd.Start()
            time.Sleep(10 * time.Millisecond)
        }()
    }
    wg.Wait()
    return nil
}
</code></pre>

<p>Разберем этот механизм:<br />
- Семафор: <code>sem := make(chan struct{}, maxParallelZombies)</code> создает канал с буфером на 50 элементов. Это ограничивает число одновременно выполняемых горутин.<br />
- WaitGroup: Используется для ожидания завершения всех горутин. <code>wg.Add(1)</code> увеличивает счетчик, <code>wg.Done()</code> уменьшает его, а <code>wg.Wait()</code> блокируется, пока счетчик не станет нулевым.<br />
- Контекст: <code>ctx.Done()</code> возвращает канал, который закрывается при отмене контекста, позволяя горутинам корректно завершиться.<br />
- Выбор с помощью <code>select</code>: Конструкция <code>select</code> позволяет выбрать между отменой через контекст и отправкой в семафор.</p>
<p>Для каждого зомби запускается команда <code>/usr/bin/true</code> (по факту код этой директивы просто <code>exit 0</code>), которая сразу завершается. Ключевой момент: демон не вызывает <code>cmd.Wait()</code>, из-за чего дочерние процессы остаются зомби.</p>
<h2 id="_7">Ответы на вопросы интервьюера</h2>
<h3 id="_8">Сколько "детей" нужно убить?</h3>
<p>Фактически, ни одного! Зомби-процессы уже "мертвы" — они завершили свое выполнение. Создание зомби происходит так:<br />
1. Родитель (демон) создает процесс.<br />
2. Дочерний процесс завершается сам (в нашем случае <code>/usr/bin/true</code> просто делает <code>exit 0</code>).<br />
3. Родитель не подтверждает их завершение (не вызывает <code>wait()</code>), поэтому ОС сохраняет их в таблице процессов как зомби.</p>
<h3 id="_9">Сколько памяти занимают зомби?</h3>
<p>Зомби-процессы сохраняют только запись в таблице процессов ядра:<br />
- Примерно 1-2 КБ на один зомби-процесс.<br />
- Для 1000 зомби: около 1-2 МБ памяти ядра.</p>
<p>Зомби не используют ни процессорное время, ни оперативную память пользовательского пространства — только минимальное место в структурах данных ядра.</p>
<h3 id="_10">Почему это работает именно так</h3>
<p>Механизм зомби — это не баг, а особенность Unix-систем. По правилам Unix, родительский процесс обязан вызвать <code>wait()</code> для завершенных дочерних процессов, чтобы получить их статус завершения. Если родитель не выполняет эту обязанность, ядро сохраняет записи как зомби. </p>
<p>Цель этого механизма — дать родительскому процессу возможность узнать статус завершения дочернего процесса в любой момент. Если родитель "забыл" это сделать или намеренно игнорирует, зомби остаются в системе.</p>
<p>В реальных системах чрезмерное количество зомби может быть проблемой, поскольку они занимают место в таблице процессов ядра, которая имеет ограниченный размер! Однако полностью избавиться от зомби в нормальных условиях можно только завершив родительский процесс — тогда все его дочерние зомби-процессы "усыновляются" процессом init (PID 1), который автоматически вызывает <code>wait()</code> и освобождает ресурсы.</p>
        </article>
    </main>
</body>
</html>